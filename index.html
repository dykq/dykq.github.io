<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  














<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url">十大排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-12T14:54:05+08:00">
                2020-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h1><hr>
<p>排序算法是《数据结构与算法》中最基本的算法之一。</p>
<p>源于：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：<strong>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</strong>等。用一张图概括：</p>
<p><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" alt="img"></p>
<p><strong>关于时间复杂度</strong>：</p>
<ol>
<li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li>
<li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</li>
<li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li>
<li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ol>
<p><strong>关于稳定性</strong>：</p>
<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>
<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
<p><strong>名词解释</strong>：</p>
<p><strong>n</strong>：数据规模</p>
<p><strong>k</strong>：“桶”的个数</p>
<p><strong>In-place</strong>：占用常数内存，不占用额外内存</p>
<p><strong>Out-place</strong>：占用额外内存</p>
<p><strong>稳定性</strong>：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p>
<h2 id="大纲内容"><a href="#大纲内容" class="headerlink" title="大纲内容"></a>大纲内容</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ol>
<pre><code>![1](E:\lately\blog\hexo\blog\source\_posts\img\冒泡.gif)</code></pre><h5 id="什么时候最快"><a href="#什么时候最快" class="headerlink" title="什么时候最快"></a>什么时候最快</h5><pre><code>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</code></pre><h5 id="什么时候最慢"><a href="#什么时候最慢" class="headerlink" title="什么时候最慢"></a>什么时候最慢</h5><pre><code>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</code></pre><h5 id="JavaScript-代码实现"><a href="#JavaScript-代码实现" class="headerlink" title="JavaScript 代码实现"></a>JavaScript 代码实现</h5><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h5><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(arr)-i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure></code></pre><h5 id="Go-代码实现"><a href="#Go-代码实现" class="headerlink" title="Go 代码实现"></a>Go 代码实现</h5><pre><code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="Java-代码实现"><a href="#Java-代码实现" class="headerlink" title="Java 代码实现"></a>Java 代码实现</h5><pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">              <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">              <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">      </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                  <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">                  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">      </span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                          <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                          arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                          arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      </span><br><span class="line">                          flag = <span class="keyword">false</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">      </span><br><span class="line">                  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> arr;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">#####  PHP 代码实现</span><br></pre></td></tr></table></figure></code></pre><p>function bubbleSort($arr)<br>{<br>    $len = count($arr);<br>    for ($i = 0; $i &lt; $len - 1; $i++) {<br>        for ($j = 0; $j &lt; $len - 1 - $i; $j++) {<br>            if ($arr[$j] &gt; $arr[$j+1]) {<br>                $tmp = $arr[$j];<br>                $arr[$j] = $arr[$j+1];<br>                $arr[$j+1] = $tmp;<br>            }<br>        }<br>    }<br>    return $arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 选择排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</span><br><span class="line"></span><br><span class="line">##### 算法步骤</span><br><span class="line"></span><br><span class="line">1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</span><br><span class="line">2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span><br><span class="line">3. 重复第二步，直到所有元素均排序完毕。</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\选择.gif)</span><br><span class="line"></span><br><span class="line">##### JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>function selectionSort(arr) {<br>    var len = arr.length;<br>    var minIndex, temp;<br>    for (var i = 0; i &lt; len - 1; i++) {<br>        minIndex = i;<br>        for (var j = i + 1; j &lt; len; j++) {<br>            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数<br>                minIndex = j;                 // 将最小数的索引保存<br>            }<br>        }<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    }<br>    return arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Python 代码实现</span><br></pre></td></tr></table></figure>
<p>def selectionSort(arr):<br>    for i in range(len(arr) - 1):<br>        # 记录最小数的索引<br>        minIndex = i<br>        for j in range(i + 1, len(arr)):<br>            if arr[j] &lt; arr[minIndex]:<br>                minIndex = j<br>        # i 不是最小数时，将 i 和最小数进行交换<br>        if i != minIndex:<br>            arr[i], arr[minIndex] = arr[minIndex], arr[i]<br>    return arr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Go 代码实现</span><br></pre></td></tr></table></figure>
<p>func selectionSort(arr []int) []int {<br>    length := len(arr)<br>    for i := 0; i &lt; length-1; i++ {<br>        min := i<br>        for j := i + 1; j &lt; length; j++ {<br>            if arr[min] &gt; arr[j] {<br>                min = j<br>            }<br>        }<br>        arr[i], arr[min] = arr[min], arr[i]<br>    }<br>    return arr<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class SelectionSort implements IArraySort {</p>
<pre><code>@Override
public int[] sort(int[] sourceArray) throws Exception {
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    // 总共要经过 N-1 轮比较
    for (int i = 0; i &lt; arr.length - 1; i++) {
        int min = i;

        // 每轮需要比较的次数 N-i
        for (int j = i + 1; j &lt; arr.length; j++) {
            if (arr[j] &lt; arr[min]) {
                // 记录目前能找到的最小值元素的下标
                min = j;
            }
        }

        // 将找到的最小值和i位置所在的值进行交换
        if (i != min) {
            int tmp = arr[i];
            arr[i] = arr[min];
            arr[min] = tmp;
        }

    }
    return arr;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function selectionSort($arr)<br>{<br>    $len = count($arr);<br>    for ($i = 0; $i &lt; $len - 1; $i++) {<br>        $minIndex = $i;<br>        for ($j = $i + 1; $j &lt; $len; $j++) {<br>            if ($arr[$j] &lt; $arr[$minIndex]) {<br>                $minIndex = $j;<br>            }<br>        }<br>        $temp = $arr[$i];<br>        $arr[$i] = $arr[$minIndex];<br>        $arr[$minIndex] = $temp;<br>    }<br>    return $arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 插入排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</span><br><span class="line"></span><br><span class="line">插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</span><br><span class="line"></span><br><span class="line">##### 算法步骤</span><br><span class="line"></span><br><span class="line">1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</span><br><span class="line">2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\插入.gif)</span><br><span class="line"></span><br><span class="line">##### JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>function insertionSort(arr) {<br>    var len = arr.length;<br>    var preIndex, current;<br>    for (var i = 1; i &lt; len; i++) {<br>        preIndex = i - 1;<br>        current = arr[i];<br>        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {<br>            arr[preIndex+1] = arr[preIndex];<br>            preIndex–;<br>        }<br>        arr[preIndex+1] = current;<br>    }<br>    return arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Python 代码实现</span><br></pre></td></tr></table></figure>
<p>def insertionSort(arr):<br>    for i in range(len(arr)):<br>        preIndex = i-1<br>        current = arr[i]<br>        while preIndex &gt;= 0 and arr[preIndex] &gt; current:<br>            arr[preIndex+1] = arr[preIndex]<br>            preIndex-=1<br>        arr[preIndex+1] = current<br>    return arr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Go 代码实现</span><br></pre></td></tr></table></figure>
<p>func insertionSort(arr []int) []int {<br>    for i := range arr {<br>        preIndex := i - 1<br>        current := arr[i]<br>        for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current {<br>            arr[preIndex+1] = arr[preIndex]<br>            preIndex -= 1<br>        }<br>        arr[preIndex+1] = current<br>    }<br>    return arr<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class InsertSort implements IArraySort {</p>
<pre><code>@Override
public int[] sort(int[] sourceArray) throws Exception {
    // 对 arr 进行拷贝，不改变参数内容
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
    for (int i = 1; i &lt; arr.length; i++) {

        // 记录要插入的数据
        int tmp = arr[i];

        // 从已经排序的序列最右边的开始比较，找到比其小的数
        int j = i;
        while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) {
            arr[j] = arr[j - 1];
            j--;
        }

        // 存在比其小的数，插入
        if (j != i) {
            arr[j] = tmp;
        }

    }
    return arr;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function insertionSort($arr)<br>{<br>    $len = count($arr);<br>    for ($i = 1; $i &lt; $len; $i++) {<br>        $preIndex = $i - 1;<br>        $current = $arr[$i];<br>        while($preIndex &gt;= 0 &amp;&amp; $arr[$preIndex] &gt; $current) {<br>            $arr[$preIndex+1] = $arr[$preIndex];<br>            $preIndex–;<br>        }<br>        $arr[$preIndex+1] = $current;<br>    }<br>    return $arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 希尔排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</span><br><span class="line"></span><br><span class="line">希尔排序是基于插入排序的以下两点性质而提出改进方法的：</span><br><span class="line"></span><br><span class="line">- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</span><br><span class="line">- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</span><br><span class="line"></span><br><span class="line">希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</span><br><span class="line"></span><br><span class="line">##### 算法步骤</span><br><span class="line"></span><br><span class="line">1. 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</span><br><span class="line">2. 按增量序列个数 k，对序列进行 k 趟排序；</span><br><span class="line">3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\希尔.gif)</span><br><span class="line"></span><br><span class="line">##### JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>function shellSort(arr) {<br>    var len = arr.length,<br>        temp,<br>        gap = 1;<br>    while(gap &lt; len/3) {          //动态定义间隔序列<br>        gap =gap*3+1;<br>    }<br>    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) {<br>        for (var i = gap; i &lt; len; i++) {<br>            temp = arr[i];<br>            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) {<br>                arr[j+gap] = arr[j];<br>            }<br>            arr[j+gap] = temp;<br>        }<br>    }<br>    return arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####  Python 代码实现</span><br></pre></td></tr></table></figure>
<p>def shellSort(arr):<br>    import math<br>    gap=1<br>    while(gap &lt; len(arr)/3):<br>        gap = gap*3+1<br>    while gap &gt; 0:<br>        for i in range(gap,len(arr)):<br>            temp = arr[i]<br>            j = i-gap<br>            while j &gt;=0 and arr[j] &gt; temp:<br>                arr[j+gap]=arr[j]<br>                j-=gap<br>            arr[j+gap] = temp<br>        gap = math.floor(gap/3)<br>    return arr<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Go 代码实现</span><br></pre></td></tr></table></figure>
<p>func shellSort(arr []int) []int {<br>    length := len(arr)<br>    gap := 1<br>    for gap &lt; gap/3 {<br>        gap = gap*3 + 1<br>    }<br>    for gap &gt; 0 {<br>        for i := gap; i &lt; length; i++ {<br>            temp := arr[i]<br>            j := i - gap<br>            for j &gt;= 0 &amp;&amp; arr[j] &gt; temp {<br>                arr[j+gap] = arr[j]<br>                j -= gap<br>            }<br>            arr[j+gap] = temp<br>        }<br>        gap = gap / 3<br>    }<br>    return arr<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class ShellSort implements IArraySort {</p>
<pre><code>@Override
public int[] sort(int[] sourceArray) throws Exception {
    // 对 arr 进行拷贝，不改变参数内容
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    int gap = 1;
    while (gap &lt; arr.length/3) {
        gap = gap * 3 + 1;
    }

    while (gap &gt; 0) {
        for (int i = gap; i &lt; arr.length; i++) {
            int tmp = arr[i];
            int j = i - gap;
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {
                arr[j + gap] = arr[j];
                j -= gap;
            }
            arr[j + gap] = tmp;
        }
        gap = (int) Math.floor(gap / 3);
    }

    return arr;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function shellSort($arr)<br>{<br>    $len = count($arr);<br>    $temp = 0;<br>    $gap = 1;<br>    while($gap &lt; $len / 3) {<br>        $gap = $gap * 3 + 1;<br>    }<br>    for ($gap; $gap &gt; 0; $gap = floor($gap / 3)) {<br>        for ($i = $gap; $i &lt; $len; $i++) {<br>            $temp = $arr[$i];<br>            for ($j = $i - $gap; $j &gt;= 0 &amp;&amp; $arr[$j] &gt; $temp; $j -= $gap) {<br>                $arr[$j+$gap] = $arr[$j];<br>            }<br>            $arr[$j+$gap] = $temp;<br>        }<br>    }<br>    return $arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 归并排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</span><br><span class="line"></span><br><span class="line">作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</span><br><span class="line"></span><br><span class="line">- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</span><br><span class="line">- 自下而上的迭代；</span><br><span class="line"></span><br><span class="line">在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</span><br><span class="line"></span><br><span class="line">&gt; However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.</span><br><span class="line">&gt;</span><br><span class="line">&gt; 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</span><br><span class="line"></span><br><span class="line">说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。</span><br><span class="line"></span><br><span class="line">和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</span><br><span class="line"></span><br><span class="line">##### 算法步骤</span><br><span class="line"></span><br><span class="line">1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</span><br><span class="line">2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；</span><br><span class="line">3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</span><br><span class="line">4. 重复步骤 3 直到某一指针达到序列尾；</span><br><span class="line">5. 将另一序列剩下的所有元素直接复制到合并序列尾。</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\归并.gif)</span><br><span class="line"></span><br><span class="line">##### JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>function mergeSort(arr) {  // 采用自上而下的递归方法<br>    var len = arr.length;<br>    if(len &lt; 2) {<br>        return arr;<br>    }<br>    var middle = Math.floor(len / 2),<br>        left = arr.slice(0, middle),<br>        right = arr.slice(middle);<br>    return merge(mergeSort(left), mergeSort(right));<br>}</p>
<p>function merge(left, right)<br>{<br>    var result = [];</p>
<pre><code>while (left.length &amp;&amp; right.length) {
    if (left[0] &lt;= right[0]) {
        result.push(left.shift());
    } else {
        result.push(right.shift());
    }
}

while (left.length)
    result.push(left.shift());

while (right.length)
    result.push(right.shift());

return result;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Python 代码实现</span><br></pre></td></tr></table></figure>
<p>def mergeSort(arr):<br>    import math<br>    if(len(arr)&lt;2):<br>        return arr<br>    middle = math.floor(len(arr)/2)<br>    left, right = arr[0:middle], arr[middle:]<br>    return merge(mergeSort(left), mergeSort(right))</p>
<p>def merge(left,right):<br>    result = []<br>    while left and right:<br>        if left[0] &lt;= right[0]:<br>            result.append(left.pop(0));<br>        else:<br>            result.append(right.pop(0));<br>    while left:<br>        result.append(left.pop(0));<br>    while right:<br>        result.append(right.pop(0));<br>    return result</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Go 代码实现</span><br></pre></td></tr></table></figure>
<p>func mergeSort(arr []int) []int {<br>    length := len(arr)<br>    if length &lt; 2 {<br>        return arr<br>    }<br>    middle := length / 2<br>    left := arr[0:middle]<br>    right := arr[middle:]<br>    return merge(mergeSort(left), mergeSort(right))<br>}</p>
<p>func merge(left []int, right []int) []int {<br>    var result []int<br>    for len(left) != 0 &amp;&amp; len(right) != 0 {<br>        if left[0] &lt;= right[0] {<br>            result = append(result, left[0])<br>            left = left[1:]<br>        } else {<br>            result = append(result, right[0])<br>            right = right[1:]<br>        }<br>    }</p>
<pre><code>for len(left) != 0 {
    result = append(result, left[0])
    left = left[1:]
}

for len(right) != 0 {
    result = append(result, right[0])
    right = right[1:]
}

return result</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class MergeSort implements IArraySort {</p>
<pre><code>@Override
public int[] sort(int[] sourceArray) throws Exception {
    // 对 arr 进行拷贝，不改变参数内容
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    if (arr.length &lt; 2) {
        return arr;
    }
    int middle = (int) Math.floor(arr.length / 2);

    int[] left = Arrays.copyOfRange(arr, 0, middle);
    int[] right = Arrays.copyOfRange(arr, middle, arr.length);

    return merge(sort(left), sort(right));
}

protected int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    int i = 0;
    while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {
        if (left[0] &lt;= right[0]) {
            result[i++] = left[0];
            left = Arrays.copyOfRange(left, 1, left.length);
        } else {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }
    }

    while (left.length &gt; 0) {
        result[i++] = left[0];
        left = Arrays.copyOfRange(left, 1, left.length);
    }

    while (right.length &gt; 0) {
        result[i++] = right[0];
        right = Arrays.copyOfRange(right, 1, right.length);
    }

    return result;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function mergeSort($arr)<br>{<br>    $len = count($arr);<br>    if ($len &lt; 2) {<br>        return $arr;<br>    }<br>    $middle = floor($len / 2);<br>    $left = array_slice($arr, 0, $middle);<br>    $right = array_slice($arr, $middle);<br>    return merge(mergeSort($left), mergeSort($right));<br>}</p>
<p>function merge($left, $right)<br>{<br>    $result = [];</p>
<pre><code>while (count($left) &gt; 0 &amp;&amp; count($right) &gt; 0) {
    if ($left[0] &lt;= $right[0]) {
        $result[] = array_shift($left);
    } else {
        $result[] = array_shift($right);
    }
}

while (count($left))
    $result[] = array_shift($left);

while (count($right))
    $result[] = array_shift($right);

return $result;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 快速排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</span><br><span class="line"></span><br><span class="line">快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</span><br><span class="line"></span><br><span class="line">快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</span><br><span class="line"></span><br><span class="line">快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</span><br><span class="line"></span><br><span class="line">&gt; 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</span><br><span class="line"></span><br><span class="line">##### 算法步骤</span><br><span class="line"></span><br><span class="line">1. 从数列中挑出一个元素，称为 “基准”（pivot）;</span><br><span class="line">2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</span><br><span class="line">3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</span><br><span class="line"></span><br><span class="line">递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\快速.gif)</span><br><span class="line"></span><br><span class="line">##### JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>function quickSort(arr, left, right) {<br>    var len = arr.length,<br>        partitionIndex,<br>        left = typeof left != ‘number’ ? 0 : left,<br>        right = typeof right != ‘number’ ? len - 1 : right;</p>
<pre><code>if (left &lt; right) {
    partitionIndex = partition(arr, left, right);
    quickSort(arr, left, partitionIndex-1);
    quickSort(arr, partitionIndex+1, right);
}
return arr;</code></pre><p>}</p>
<p>function partition(arr, left ,right) {     // 分区操作<br>    var pivot = left,                      // 设定基准值（pivot）<br>        index = pivot + 1;<br>    for (var i = index; i &lt;= right; i++) {<br>        if (arr[i] &lt; arr[pivot]) {<br>            swap(arr, i, index);<br>            index++;<br>        }<br>    }<br>    swap(arr, pivot, index - 1);<br>    return index-1;<br>}</p>
<p>function swap(arr, i, j) {<br>    var temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>}<br>function partition2(arr, low, high) {<br>  let pivot = arr[low];<br>  while (low &lt; high) {<br>    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) {<br>      –high;<br>    }<br>    arr[low] = arr[high];<br>    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) {<br>      ++low;<br>    }<br>    arr[high] = arr[low];<br>  }<br>  arr[low] = pivot;<br>  return low;<br>}</p>
<p>function quickSort2(arr, low, high) {<br>  if (low &lt; high) {<br>    let pivot = partition2(arr, low, high);<br>    quickSort2(arr, low, pivot - 1);<br>    quickSort2(arr, pivot + 1, high);<br>  }<br>  return arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####  Python 代码实现</span><br></pre></td></tr></table></figure>
<p>def quickSort(arr, left=None, right=None):<br>    left = 0 if not isinstance(left,(int, float)) else left<br>    right = len(arr)-1 if not isinstance(right,(int, float)) else right<br>    if left &lt; right:<br>        partitionIndex = partition(arr, left, right)<br>        quickSort(arr, left, partitionIndex-1)<br>        quickSort(arr, partitionIndex+1, right)<br>    return arr</p>
<p>def partition(arr, left, right):<br>    pivot = left<br>    index = pivot+1<br>    i = index<br>    while  i &lt;= right:<br>        if arr[i] &lt; arr[pivot]:<br>            swap(arr, i, index)<br>            index+=1<br>        i+=1<br>    swap(arr,pivot,index-1)<br>    return index-1</p>
<p>def swap(arr, i, j):<br>    arr[i], arr[j] = arr[j], arr[i]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####  Go 代码实现</span><br></pre></td></tr></table></figure>
<p>func quickSort(arr []int) []int {<br>    return _quickSort(arr, 0, len(arr)-1)<br>}</p>
<p>func _quickSort(arr []int, left, right int) []int {<br>    if left &lt; right {<br>        partitionIndex := partition(arr, left, right)<br>        _quickSort(arr, left, partitionIndex-1)<br>        _quickSort(arr, partitionIndex+1, right)<br>    }<br>    return arr<br>}</p>
<p>func partition(arr []int, left, right int) int {<br>    pivot := left<br>    index := pivot + 1</p>
<pre><code>for i := index; i &lt;= right; i++ {
    if arr[i] &lt; arr[pivot] {
        swap(arr, i, index)
        index += 1
    }
}
swap(arr, pivot, index-1)
return index - 1</code></pre><p>}</p>
<p>func swap(arr []int, i, j int) {<br>    arr[i], arr[j] = arr[j], arr[i]<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### C++版</span><br></pre></td></tr></table></figure>

<p> Paritition1(int A[], int low, int high) {<br>   int pivot = A[low];<br>   while (low &lt; high) {<br>     while (low &lt; high &amp;&amp; A[high] &gt;= pivot) {<br>       –high;<br>     }<br>     A[low] = A[high];<br>     while (low &lt; high &amp;&amp; A[low] &lt;= pivot) {<br>       ++low;<br>     }<br>     A[high] = A[low];<br>   }<br>   A[low] = pivot;<br>   return low;<br> }</p>
<p> void QuickSort(int A[], int low, int high) //快排母函数<br> {<br>   if (low &lt; high) {<br>     int pivot = Paritition1(A, low, high);<br>     QuickSort(A, low, pivot - 1);<br>     QuickSort(A, pivot + 1, high);<br>   }<br> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class QuickSort implements IArraySort {</p>
<pre><code>@Override
public int[] sort(int[] sourceArray) throws Exception {
    // 对 arr 进行拷贝，不改变参数内容
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    return quickSort(arr, 0, arr.length - 1);
}

private int[] quickSort(int[] arr, int left, int right) {
    if (left &lt; right) {
        int partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
    }
    return arr;
}

private int partition(int[] arr, int left, int right) {
    // 设定基准值（pivot）
    int pivot = left;
    int index = pivot + 1;
    for (int i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }
    }
    swap(arr, pivot, index - 1);
    return index - 1;
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function quickSort($arr)<br>{<br>    if (count($arr) &lt;= 1)<br>        return $arr;<br>    $middle = $arr[0];<br>    $leftArray = array();<br>    $rightArray = array();</p>
<pre><code>for ($i = 1; $i &lt; count($arr); $i++) {
    if ($arr[$i] &gt; $middle)
        $rightArray[] = $arr[$i];
    else
        $leftArray[] = $arr[$i];
}
$leftArray = quickSort($leftArray);
$leftArray[] = $middle;

$rightArray = quickSort($rightArray);
return array_merge($leftArray, $rightArray);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 堆排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</span><br><span class="line"></span><br><span class="line">1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</span><br><span class="line">2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</span><br><span class="line"></span><br><span class="line">堆排序的平均时间复杂度为 Ο(nlogn)。</span><br><span class="line"></span><br><span class="line">#####  算法步骤</span><br><span class="line"></span><br><span class="line">1. 将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；</span><br><span class="line">2. 把堆首（最大值）和堆尾互换；</span><br><span class="line">3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</span><br><span class="line">4. 重复步骤 2，直到堆的尺寸为 1。</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\堆排序.gif)</span><br><span class="line"></span><br><span class="line">##### JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</p>
<p>function buildMaxHeap(arr) {   // 建立大顶堆<br>    len = arr.length;<br>    for (var i = Math.floor(len/2); i &gt;= 0; i–) {<br>        heapify(arr, i);<br>    }<br>}</p>
<p>function heapify(arr, i) {     // 堆调整<br>    var left = 2 * i + 1,<br>        right = 2 * i + 2,<br>        largest = i;</p>
<pre><code>if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
    largest = left;
}

if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
    largest = right;
}

if (largest != i) {
    swap(arr, i, largest);
    heapify(arr, largest);
}</code></pre><p>}</p>
<p>function swap(arr, i, j) {<br>    var temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>}</p>
<p>function heapSort(arr) {<br>    buildMaxHeap(arr);</p>
<pre><code>for (var i = arr.length-1; i &gt; 0; i--) {
    swap(arr, 0, i);
    len--;
    heapify(arr, 0);
}
return arr;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Python 代码实现</span><br></pre></td></tr></table></figure>
<p>def buildMaxHeap(arr):<br>    import math<br>    for i in range(math.floor(len(arr)/2),-1,-1):<br>        heapify(arr,i)</p>
<p>def heapify(arr, i):<br>    left = 2<em>i+1<br>    right = 2</em>i+2<br>    largest = i<br>    if left &lt; arrLen and arr[left] &gt; arr[largest]:<br>        largest = left<br>    if right &lt; arrLen and arr[right] &gt; arr[largest]:<br>        largest = right</p>
<pre><code>if largest != i:
    swap(arr, i, largest)
    heapify(arr, largest)</code></pre><p>def swap(arr, i, j):<br>    arr[i], arr[j] = arr[j], arr[i]</p>
<p>def heapSort(arr):<br>    global arrLen<br>    arrLen = len(arr)<br>    buildMaxHeap(arr)<br>    for i in range(len(arr)-1,0,-1):<br>        swap(arr,0,i)<br>        arrLen -=1<br>        heapify(arr, 0)<br>    return arr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Go 代码实现</span><br></pre></td></tr></table></figure>
<p>func heapSort(arr []int) []int {<br>    arrLen := len(arr)<br>    buildMaxHeap(arr, arrLen)<br>    for i := arrLen - 1; i &gt;= 0; i– {<br>        swap(arr, 0, i)<br>        arrLen -= 1<br>        heapify(arr, 0, arrLen)<br>    }<br>    return arr<br>}</p>
<p>func buildMaxHeap(arr []int, arrLen int) {<br>    for i := arrLen / 2; i &gt;= 0; i– {<br>        heapify(arr, i, arrLen)<br>    }<br>}</p>
<p>func heapify(arr []int, i, arrLen int) {<br>    left := 2<em>i + 1<br>    right := 2</em>i + 2<br>    largest := i<br>    if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] {<br>        largest = left<br>    }<br>    if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] {<br>        largest = right<br>    }<br>    if largest != i {<br>        swap(arr, i, largest)<br>        heapify(arr, largest, arrLen)<br>    }<br>}</p>
<p>func swap(arr []int, i, j int) {<br>    arr[i], arr[j] = arr[j], arr[i]<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class HeapSort implements IArraySort {</p>
<pre><code>@Override
public int[] sort(int[] sourceArray) throws Exception {
    // 对 arr 进行拷贝，不改变参数内容
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    int len = arr.length;

    buildMaxHeap(arr, len);

    for (int i = len - 1; i &gt; 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0, len);
    }
    return arr;
}

private void buildMaxHeap(int[] arr, int len) {
    for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) {
        heapify(arr, i, len);
    }
}

private void heapify(int[] arr, int i, int len) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest, len);
    }
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function buildMaxHeap(&amp;$arr)<br>{<br>    global $len;<br>    for ($i = floor($len/2); $i &gt;= 0; $i–) {<br>        heapify($arr, $i);<br>    }<br>}</p>
<p>function heapify(&amp;$arr, $i)<br>{<br>    global $len;<br>    $left = 2 * $i + 1;<br>    $right = 2 * $i + 2;<br>    $largest = $i;</p>
<pre><code>if ($left &lt; $len &amp;&amp; $arr[$left] &gt; $arr[$largest]) {
    $largest = $left;
}

if ($right &lt; $len &amp;&amp; $arr[$right] &gt; $arr[$largest]) {
    $largest = $right;
}

if ($largest != $i) {
    swap($arr, $i, $largest);
    heapify($arr, $largest);
}</code></pre><p>}</p>
<p>function swap(&amp;$arr, $i, $j)<br>{<br>    $temp = $arr[$i];<br>    $arr[$i] = $arr[$j];<br>    $arr[$j] = $temp;<br>}</p>
<p>function heapSort($arr) {<br>    global $len;<br>    $len = count($arr);<br>    buildMaxHeap($arr);<br>    for ($i = count($arr) - 1; $i &gt; 0; $i–) {<br>        swap($arr, 0, $i);<br>        $len–;<br>        heapify($arr, 0);<br>    }<br>    return $arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 计数排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</span><br><span class="line"></span><br><span class="line">#####  算法描述</span><br><span class="line"></span><br><span class="line">1.找出待排序的数组中最大和最小的元素；</span><br><span class="line"></span><br><span class="line">2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</span><br><span class="line"></span><br><span class="line">3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</span><br><span class="line"></span><br><span class="line">4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\计数.gif)</span><br><span class="line"></span><br><span class="line">#####  JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>function countingSort(arr, maxValue) {<br>    var bucket = new Array(maxValue+1),<br>        sortedIndex = 0;<br>        arrLen = arr.length,<br>        bucketLen = maxValue + 1;</p>
<pre><code>for (var i = 0; i &lt; arrLen; i++) {
    if (!bucket[arr[i]]) {
        bucket[arr[i]] = 0;
    }
    bucket[arr[i]]++;
}

for (var j = 0; j &lt; bucketLen; j++) {
    while(bucket[j] &gt; 0) {
        arr[sortedIndex++] = j;
        bucket[j]--;
    }
}

return arr;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Python 代码实现</span><br></pre></td></tr></table></figure>
<p>def countingSort(arr, maxValue):<br>    bucketLen = maxValue+1<br>    bucket = [0]*bucketLen<br>    sortedIndex =0<br>    arrLen = len(arr)<br>    for i in range(arrLen):<br>        if not bucket[arr[i]]:<br>            bucket[arr[i]]=0<br>        bucket[arr[i]]+=1<br>    for j in range(bucketLen):<br>        while bucket[j]&gt;0:<br>            arr[sortedIndex] = j<br>            sortedIndex+=1<br>            bucket[j]-=1<br>    return arr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Go 代码实现</span><br></pre></td></tr></table></figure>
<p>func countingSort(arr []int, maxValue int) []int {<br>    bucketLen := maxValue + 1<br>    bucket := make([]int, bucketLen) // 初始为0的数组</p>
<pre><code>sortedIndex := 0
length := len(arr)

for i := 0; i &lt; length; i++ {
    bucket[arr[i]] += 1
}

for j := 0; j &lt; bucketLen; j++ {
    for bucket[j] &gt; 0 {
        arr[sortedIndex] = j
        sortedIndex += 1
        bucket[j] -= 1
    }
}

return arr</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class CountingSort implements IArraySort {</p>
<pre><code>@Override
public int[] sort(int[] sourceArray) throws Exception {
    // 对 arr 进行拷贝，不改变参数内容
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    int maxValue = getMaxValue(arr);

    return countingSort(arr, maxValue);
}

private int[] countingSort(int[] arr, int maxValue) {
    int bucketLen = maxValue + 1;
    int[] bucket = new int[bucketLen];

    for (int value : arr) {
        bucket[value]++;
    }

    int sortedIndex = 0;
    for (int j = 0; j &lt; bucketLen; j++) {
        while (bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }
    return arr;
}

private int getMaxValue(int[] arr) {
    int maxValue = arr[0];
    for (int value : arr) {
        if (maxValue &lt; value) {
            maxValue = value;
        }
    }
    return maxValue;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function countingSort($arr, $maxValue = null)<br>{<br>    if ($maxValue === null) {<br>        $maxValue = max($arr);<br>    }<br>    for ($m = 0; $m &lt; $maxValue + 1; $m++) {<br>        $bucket[] = null;<br>    }</p>
<pre><code>$arrLen = count($arr);
for ($i = 0; $i &lt; $arrLen; $i++) {
    if (!array_key_exists($arr[$i], $bucket)) {
        $bucket[$arr[$i]] = 0;
    }
    $bucket[$arr[$i]]++;
}

$sortedIndex = 0;
foreach ($bucket as $key =&gt; $len) {
    if($len !== null){
        for($j = 0; $j &lt; $len; $j++){
            $arr[$sortedIndex++] = $key;
        }
    }
}

return $arr;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 桶排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</span><br><span class="line"></span><br><span class="line">为了使桶排序更加高效，我们需要做到这两点：</span><br><span class="line"></span><br><span class="line">1. 在额外空间充足的情况下，尽量增大桶的数量</span><br><span class="line">2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</span><br><span class="line"></span><br><span class="line">同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</span><br><span class="line"></span><br><span class="line">##### 算法描述</span><br><span class="line"></span><br><span class="line">- 设置一个定量的数组当作空桶；</span><br><span class="line">- 遍历输入数据，并且把数据一个一个放到对应的桶里去；</span><br><span class="line">- 对每个不是空的桶进行排序；</span><br><span class="line">- 从不是空的桶里把排好序的数据拼接起来。 </span><br><span class="line"></span><br><span class="line">##### 什么时候最快</span><br><span class="line"></span><br><span class="line">当输入的数据可以均匀的分配到每一个桶中。</span><br><span class="line"></span><br><span class="line">#####  什么时候最慢</span><br><span class="line"></span><br><span class="line">当输入的数据被分配到了同一个桶中。</span><br><span class="line"></span><br><span class="line">![](E:\lately\blog\hexo\blog\source\_posts\img\桶排序.png)</span><br><span class="line"></span><br><span class="line">##### javaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>function bucketSort(arr, bucketSize) {<br>    if (arr.length === 0) {<br>      return arr;<br>    }</p>
<pre><code>var i;
var minValue = arr[0];
var maxValue = arr[0];
for (i = 1; i &lt; arr.length; i++) {
  if (arr[i] &lt; minValue) {
      minValue = arr[i];                // 输入数据的最小值
  } else if (arr[i] &gt; maxValue) {
      maxValue = arr[i];                // 输入数据的最大值
  }
}

//桶的初始化
var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   
var buckets = new Array(bucketCount);
for (i = 0; i &lt; buckets.length; i++) {
    buckets[i] = [];
}

//利用映射函数将数据分配到各个桶中
for (i = 0; i &lt; arr.length; i++) {
    buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
}

arr.length = 0;
for (i = 0; i &lt; buckets.length; i++) {
    insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
    for (var j = 0; j &lt; buckets[i].length; j++) {
        arr.push(buckets[i][j]);                      
    }
}

return arr;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Java 代码实现</span><br></pre></td></tr></table></figure>
<p>public class BucketSort implements IArraySort {</p>
<pre><code>private static final InsertSort insertSort = new InsertSort();

@Override
public int[] sort(int[] sourceArray) throws Exception {
    // 对 arr 进行拷贝，不改变参数内容
    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

    return bucketSort(arr, 5);
}

private int[] bucketSort(int[] arr, int bucketSize) throws Exception {
    if (arr.length == 0) {
        return arr;
    }

    int minValue = arr[0];
    int maxValue = arr[0];
    for (int value : arr) {
        if (value &lt; minValue) {
            minValue = value;
        } else if (value &gt; maxValue) {
            maxValue = value;
        }
    }

    int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;
    int[][] buckets = new int[bucketCount][0];

    // 利用映射函数将数据分配到各个桶中
    for (int i = 0; i &lt; arr.length; i++) {
        int index = (int) Math.floor((arr[i] - minValue) / bucketSize);
        buckets[index] = arrAppend(buckets[index], arr[i]);
    }

    int arrIndex = 0;
    for (int[] bucket : buckets) {
        if (bucket.length &lt;= 0) {
            continue;
        }
        // 对每个桶进行排序，这里使用了插入排序
        bucket = insertSort.sort(bucket);
        for (int value : bucket) {
            arr[arrIndex++] = value;
        }
    }

    return arr;
}

/**
 * 自动扩容，并保存数据
 *
 * @param arr
 * @param value
 */
private int[] arrAppend(int[] arr, int value) {
    arr = Arrays.copyOf(arr, arr.length + 1);
    arr[arr.length - 1] = value;
    return arr;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function bucketSort($arr, $bucketSize = 5)<br>{<br>    if (count($arr) === 0) {<br>      return $arr;<br>    }</p>
<pre><code>$minValue = $arr[0];
$maxValue = $arr[0];
for ($i = 1; $i &lt; count($arr); $i++) {
  if ($arr[$i] &lt; $minValue) {
      $minValue = $arr[$i];
  } else if ($arr[$i] &gt; $maxValue) {
      $maxValue = $arr[$i];
  }
}

$bucketCount = floor(($maxValue - $minValue) / $bucketSize) + 1;
$buckets = array();
for ($i = 0; $i &lt; count($buckets); $i++) {
    $buckets[$i] = [];
}

for ($i = 0; $i &lt; count($arr); $i++) {
    $buckets[floor(($arr[$i] - $minValue) / $bucketSize)][] = $arr[$i];
}

$arr = array();
for ($i = 0; $i &lt; count($buckets); $i++) {
    $bucketTmp = $buckets[$i];
    sort($bucketTmp);
    for ($j = 0; $j &lt; count($bucketTmp); $j++) {
        $arr[] = $bucketTmp[$j];
    }
}

return $arr;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 基数排序</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</span><br><span class="line"></span><br><span class="line">基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</span><br><span class="line"></span><br><span class="line">#####  算法描述</span><br><span class="line"></span><br><span class="line">- 取得数组中的最大数，并取得位数；</span><br><span class="line"></span><br><span class="line">- arr为原始数组，从最低位开始取每个位组成radix数组；</span><br><span class="line"></span><br><span class="line">- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span><br><span class="line"></span><br><span class="line">  ![](E:\lately\blog\hexo\blog\source\_posts\img\基数.gif)</span><br><span class="line"></span><br><span class="line">#### 基数排序 vs 计数排序 vs 桶排序</span><br><span class="line"></span><br><span class="line">基数排序有两种方法：</span><br><span class="line"></span><br><span class="line">这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：</span><br><span class="line"></span><br><span class="line">- 基数排序：根据键值的每位数字来分配桶；</span><br><span class="line">- 计数排序：每个桶只存储单一键值；</span><br><span class="line">- 桶排序：每个桶存储一定范围的数值；</span><br><span class="line"></span><br><span class="line">##### JavaScript 代码实现</span><br></pre></td></tr></table></figure>
<p>//LSD Radix Sort<br>var counter = [];<br>function radixSort(arr, maxDigit) {<br>    var mod = 10;<br>    var dev = 1;<br>    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {<br>        for(var j = 0; j &lt; arr.length; j++) {<br>            var bucket = parseInt((arr[j] % mod) / dev);<br>            if(counter[bucket]==null) {<br>                counter[bucket] = [];<br>            }<br>            counter[bucket].push(arr[j]);<br>        }<br>        var pos = 0;<br>        for(var j = 0; j &lt; counter.length; j++) {<br>            var value = null;<br>            if(counter[j]!=null) {<br>                while ((value = counter[j].shift()) != null) {<br>                      arr[pos++] = value;<br>                }<br>          }<br>        }<br>    }<br>    return arr;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####  python 代码实现</span><br></pre></td></tr></table></figure>
<p>def radix(arr):</p>
<pre><code>digit = 0
max_digit = 1
max_value = max(arr)
#找出列表中最大的位数
while 10**max_digit &lt; max_value:
    max_digit = max_digit + 1

while digit &lt; max_digit:
    temp = [[] for i in range(10)]
    for i in arr:
        #求出每一个元素的个、十、百位的值
        t = int((i/10**digit)%10)
        temp[t].append(i)

    coll = []
    for bucket in temp:
        for i in bucket:
            coll.append(i)

    arr = coll
    digit = digit + 1

return arr</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####  Java 代码实现</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li><p>基数排序</p>
</li>
<li><p>考虑负数的情况还可以参考： <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a></p>
</li>
<li><p>/<br>public class RadixSort implements IArraySort {</p>
<p>  @Override<br>  public int[] sort(int[] sourceArray) throws Exception {</p>
<pre><code>// 对 arr 进行拷贝，不改变参数内容
int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

int maxDigit = getMaxDigit(arr);
return radixSort(arr, maxDigit);</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li><p>获取最高位数</p>
</li>
<li><p>/<br>private int getMaxDigit(int[] arr) {<br>  int maxValue = getMaxValue(arr);<br>  return getNumLenght(maxValue);<br>}</p>
<p>private int getMaxValue(int[] arr) {<br>  int maxValue = arr[0];<br>  for (int value : arr) {</p>
<pre><code>if (maxValue &lt; value) {
    maxValue = value;
}</code></pre><p>  }<br>  return maxValue;<br>}</p>
<p>protected int getNumLenght(long num) {<br>  if (num == 0) {</p>
<pre><code>return 1;</code></pre><p>  }<br>  int lenght = 0;<br>  for (long temp = num; temp != 0; temp /= 10) {</p>
<pre><code>lenght++;</code></pre><p>  }<br>  return lenght;<br>}</p>
<p>private int[] radixSort(int[] arr, int maxDigit) {<br>  int mod = 10;<br>  int dev = 1;</p>
<p>  for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {</p>
<pre><code>// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)
int[][] counter = new int[mod * 2][0];

for (int j = 0; j &lt; arr.length; j++) {
    int bucket = ((arr[j] % mod) / dev) + mod;
    counter[bucket] = arrayAppend(counter[bucket], arr[j]);
}

int pos = 0;
for (int[] bucket : counter) {
    for (int value : bucket) {
        arr[pos++] = value;
    }
}</code></pre><p>  }</p>
<p>  return arr;<br>}</p>
<p>/**</p>
</li>
<li><p>自动扩容，并保存数据</p>
</li>
<li></li>
<li><p>@param arr</p>
</li>
<li><p>@param value</p>
</li>
<li><p>/<br>private int[] arrayAppend(int[] arr, int value) {<br>  arr = Arrays.copyOf(arr, arr.length + 1);<br>  arr[arr.length - 1] = value;<br>  return arr;<br>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####  PHP 代码实现</span><br></pre></td></tr></table></figure>
<p>function radixSort($arr, $maxDigit = null)<br>{<br>if ($maxDigit === null) {<br>  $maxDigit = max($arr);<br>}<br>$counter = [];<br>for ($i = 0; $i &lt; $maxDigit; $i++) {<br>  for ($j = 0; $j &lt; count($arr); $j++) {</p>
<pre><code>preg_match_all(&apos;/\d/&apos;, (string) $arr[$j], $matches);
$numArr = $matches[0];
$lenTmp = count($numArr);
$bucket = array_key_exists($lenTmp - $i - 1, $numArr)
    ? intval($numArr[$lenTmp - $i - 1])
    : 0;
if (!array_key_exists($bucket, $counter)) {
    $counter[$bucket] = [];
}
$counter[$bucket][] = $arr[$j];</code></pre><p>  }<br>  $pos = 0;<br>  for ($j = 0; $j &lt; count($counter); $j++) {</p>
<pre><code>  $value = null;
  if ($counter[$j] !== null) {
      while (($value = array_shift($counter[$j])) !== null) {
          $arr[$pos++] = $value;
      }
}</code></pre><p>  }<br>}</p>
<p>return $arr;<br>}<br>```</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" itemprop="url">Hexo搭建博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T14:00:34+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h1><h3 id="一、本地安装git"><a href="#一、本地安装git" class="headerlink" title="一、本地安装git"></a>一、本地安装git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git 是一个开源的分布式版本控制系统</span><br></pre></td></tr></table></figure>

<p>下载地址:<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a>, 按照默认方式安装即可</p>
<p>（ps：如果已经安装了git可以通过$ git clone <a href="https://github.com/git/git去获得最新版本）" target="_blank" rel="noopener">https://github.com/git/git去获得最新版本）</a></p>
<p>本地的桌面右键出现了gitBashHere则证明安装成功</p>
<h3 id="二、安装node-js"><a href="#二、安装node-js" class="headerlink" title="二、安装node.js"></a>二、安装node.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node.js 是一个基于 Google V8 引擎的 JavaScript 环境，它支持在后端运行 JavaScript</span><br><span class="line"></span><br><span class="line">而 NPM 是默认与 Node.js 一起安装的包管理工具</span><br></pre></td></tr></table></figure>

<p>比如将node.js安装在了D:\node\目录下</p>
<p>在该目录下创建文件夹<code>node_global</code>和<code>node_cache</code> 并执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;D:\node\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\node\node_cache&quot;</span><br></pre></td></tr></table></figure>

<p>在系统环境变量中增加NODE_PATH， 在用户环境变量path下增加变量，变量值都为D:\node\node_global</p>
<p>接着下载Hexo,在cmd中执行npm install -g hexo</p>
<h3 id="三、hexo本地建站"><a href="#三、hexo本地建站" class="headerlink" title="三、hexo本地建站"></a>三、hexo本地建站</h3><h4 id="1-本地建站"><a href="#1-本地建站" class="headerlink" title="1.本地建站"></a>1.本地建站</h4><p>找一个合适的文件夹作为hexo的根目录,用来存本地文件，在该文件夹下打开cmd 并执行<code>hexo init</code> 和 <code>npm install</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init 命令可以将该文件夹初始化为 Hexo 根目录</span><br><span class="line"></span><br><span class="line">npm install 命令可以自动安装依赖列表中列出的所有模块</span><br></pre></td></tr></table></figure>

<h4 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2.基本配置"></a>2.基本配置</h4><p>打开 <strong>根目录</strong> 下的 <code>_config.yml</code> 文件，它是一个配置文件，可以直接用记事本打开</p>
<p>注意在设置时，属性与值之间需要留有一个空格，例如：<code>language: zh-CN</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Site 网站相关配置</span><br><span class="line">title	        网站标题</span><br><span class="line">subtitle	    网站副标题</span><br><span class="line">description	    网站描述</span><br><span class="line">keywords        网站关键词</span><br><span class="line">author	        网站作者名字</span><br><span class="line">language	    网站使用的语言，这里填zh-CN</span><br><span class="line">timezone	    网站使用的时区，这里默认使用电脑的时区</span><br></pre></td></tr></table></figure>

<h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h4><p>至此，利用 Hexo 搭建的个人博客网站已经可以在本地上正常运行了</p>
<p>我们一起来看看效果吧，打开 git bash，输入命令 <code>hexo s</code> 启动本地站点 在建立的文件夹的hexo 的blog目录下打开执行也可以</p>
<h4 id="4-安装插件"><a href="#4-安装插件" class="headerlink" title="4.安装插件"></a>4.安装插件</h4><p>执行代码npm install hexo-deployer-git –save</p>
<h4 id="5-配置修改"><a href="#5-配置修改" class="headerlink" title="5.配置修改"></a>5.配置修改</h4><p>在根目录的_config.yml文件夹下进行如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>其中repo为你自己GitHub上的名字地址</p>
<h4 id="6-发布网页"><a href="#6-发布网页" class="headerlink" title="6.发布网页"></a>6.发布网页</h4><p>在相对应的目录下打开gitbash或者cmd之后输入hexo g生成静态文件在输入hexo d 部署到github</p>
<p>完成后在网页中输入username.github.io 就可以访问你已经部署的网站啦！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/My-New-Post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/My-New-Post/" itemprop="url">My New Post</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T12:11:07+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/2020-06-05-hexo-%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/2020-06-05-hexo-%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95/" itemprop="url">hexo 部署测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T12:11:07+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我是</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T11:56:42+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
